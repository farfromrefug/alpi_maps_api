{
  "name": "spawn-async",
  "version": "0.0.1",
  "description": "spawn child processes asynchronously",
  "main": "lib/spawn-async.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-spawn-async.git"
  },
  "keywords": [
    "spawn",
    "async",
    "fork",
    "exec"
  ],
  "license": "MIT",
  "readmeFilename": "README.md",
  "optionalDependencies": {
    "bunyan": "*"
  },
  "readme": "# spawn-async: spawn child processes asynchronously\n\n## Synopsis\n\n    var mod_spawnasync = require('spawn-async');\n    var worker = mod_spawnasync.createWorker({ 'log': log });\n\n    /* ... */\n\n    /*\n     * \"aspawn\" is a simpler version of Node's execFile interface, closer to\n     * execve(2) in the way arguments are specified, but buffering stdout and\n     * stderr like Node's \"exec\" and \"execFile\".  The main difference is that\n     * the child is forked from a child process, avoiding blocking the main loop\n     * or duplicating the heap (even virtually).\n     */\n    worker.aspawn(['ls', '-l', '/etc/passwd'],\n        function (err, stdout, stderr) {\n            if (err) {\n                console.log('error: %s', err.message);\n                console.error(stderr);\n            } else {\n                console.log(stdout);\n            }\n        });\n\n\n## Why?\n\nWhile Node's `child_process` module makes it convenient to execute shell\ncommands from Node programs, doing so even occasionally in an otherwise busy\nserver process can result in significant latency bubbles.  Besides that, forking\na Node server with a large heap just to exec some other program causes a\nsignificant amount of additional swap to be used, which is problematic in\nlow-memory environments.  This module provides an interface for spawning new\nprocesses using a worker process to do the actual fork/exec.  This worker\nprocess itself is spawned when create a Worker object, and you should do this\nonly once when you initialize the server.\n\n**Details**: Node implements spawn() and related functions synchronously in the\nmain thread, waiting not only for the fork(2) to complete (which itself can take\nmany milliseconds, and requires waiting for all other threads to stop), but also\nfor the child process to exit(3c) or exec(2).  While workloads that make\nexcessive use of fork(2) are hardly high-performance to begin with, the behavior\nof blocking the main thread for hundreds of milliseconds each time is\nunnecessarily pathological for otherwise reasonable workloads.\n\n\n## API\n\nThe basic object is the `Worker`, created with `createWorker(options)`.  The\nonly supported option is \"log\", which is required and should be a\nnode-bunyan-style logger.  The resulting object is an EventEmitter with the\nfollowing methods:\n\n`aspawn(argv, [options], callback)`: invokes the program identified by argv,\nwaits for it to exit, buffers stdout and stderr, and invokes `callback(err,\nstdout, stderr)` (just like Node's execFile).  aspawn does not support pipelines\nor other shell syntax; for that, just invoke `bash -c \"...\"` instead.\n\n`argv` is an array of arguments *including* the program name itself; this is\ndifferent than Node's child\\_process module but is consistent with the exec\nfamily of POSIX functions and how shells work.\n\n`options` may be an object with the following property:\n\n* `env`: program environment (see exec(2); default: current environment)\n\nThe stdout and stderr encoding is always `'utf8'`.\n\n`destroy()`: forcefully kills the worker process and causes pending `aspawn`\ncommands to fail.  The behavior with respect to the corresponding child\nprocesses is undefined, so you should only call this when you know there are no\noutstanding commands, when you don't care about leaving orphaned child processes\naround, or your system will automatically clean up such child processes.\n\n### Events\n\nWorkers may emit the following events:\n\n`exit (err)`: the worker process has exited.  You can usually ignore this event.\nThis event fires when the worker exits normally as a result of a call to\n`destroy()` (in which case `err` is null), as well as when the worker exits\nabnormally (in which case it will be restarted automatically).\n\n`error (err)`: fatal error on this Worker.  This is not fatal to the Node\nprogram, but indicates that the worker will be unable to process any subsequent\ncommands.  The only normal circumstances when this should happen is if the\nworker process exits abnormally and cannot be restarted.\n\n\n### What about everything else?\n\nNode's `child_process` module supports several other functions and options not\nsupported here.  They fall into a few categories.\n\nCommands using shell syntax (i.e., `exec`, as opposed to `execFile`) can be\nexecuted by just executing `bash -c \"...\"` with `aspawn`.\n\nThe `cwd`, `timeout`, `maxBuffer`, `killSignal`, and `stdio` options, along with\nan interface for streaming stdout and stderr (i.e. `spawn` instead of\n`execFile`) could in principle be supported, but usage of these features\nsuggests something less simple than just executing a small, independent shell\ncommand.  The robustness and performance implications of doing that from a\nhigh-volume server should be considered very carefully.\n\n\n## Implementation notes\n\nThe implementation restarts the worker process immediately if it ever exits\nabnormally.  There's no reason this should happen under normal operation, but\nit can happen if the process crashes or an operator kills it, and it has the\nsame latency and memory impact described above.  If this becomes problematic, it\nwould be possible to avoid automatically restarting the worker and instead give\nthe caller control over when it gets restarted.  Since such a change could be\nmade backwards-compatibly and it seems unlikely anyone would ever use this\nfeature, it's not yet implemented.\n\nThe child process itself is currently implemented as a Node process for rapid\ndevelopment, but it could easily be made a C program to reduce the memory\noverhead.\n",
  "_id": "spawn-async@0.0.1",
  "dependencies": {
    "bunyan": "*"
  },
  "dist": {
    "shasum": "c5acca1f94cf4f201b5852f1c6efb2141899cc4d",
    "tarball": "http://registry.npmjs.org/spawn-async/-/spawn-async-0.0.1.tgz"
  },
  "_from": "spawn-async@latest",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "dap",
    "email": "dap@cs.brown.edu"
  },
  "maintainers": [
    {
      "name": "dap",
      "email": "dap@cs.brown.edu"
    }
  ],
  "directories": {},
  "_shasum": "c5acca1f94cf4f201b5852f1c6efb2141899cc4d",
  "_resolved": "https://registry.npmjs.org/spawn-async/-/spawn-async-0.0.1.tgz"
}
